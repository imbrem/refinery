import Refinery.Model
import Refinery.Ctx.Basic
import Refinery.Ctx.SSplit

import Discretion.Premonoidal.BraidedHelpers
import Discretion.Premonoidal.Category
import Discretion.Monoidal.CoherenceLemmas

namespace Refinery

open CategoryTheory

open PremonoidalCategory MonoidalCategory'

open scoped MonoidalCategory

open EffectfulCategory

section TyModel

variable {Œ± : Type _} [HasQuant Œ±]
         {C : Type _} [Category C] [MonoidalCategoryStruct C] [ChosenFiniteCoproducts C]
         [TyModel Œ± C]

notation "v‚ü¶" v "‚üß" => t‚ü¶ Var?.ety v ‚üß

abbrev Ctx?.den (Œì : Ctx? Œ±) : C := t‚ü¶Œì.ety‚üß

notation "g‚ü¶" Œì "‚üß" => Ctx?.den Œì

end TyModel

section VarModel


variable {œÜ : Type _} {Œ± : Type _} {Œµ : Type _} [Signature œÜ Œ± Œµ]
         {C : Type _} [Category C] [ChosenFiniteCoproducts C]

section MonoidalCategoryStruct

variable [MonoidalCategoryStruct C] [VM : VarModel Œ± C]

def Var?.Wk.den {v w : Var? Œ±} (h : v.Wk w) : (v‚ü¶ v ‚üß : C) ‚ü∂ v‚ü¶ w ‚üß
  := match v, w, h with
  | v, ‚ü®B, 0‚ü©, h => haveI _ := (h.unused_del rfl); !_ _
  | ‚ü®A, (_ : Quant)‚ü©, ‚ü®B, (_ : Quant)‚ü©, h => eqToHom (by cases h.ty; rfl)

abbrev Var?.del.den {v : Var? Œ±} (h : v.del) : (v‚ü¶ v ‚üß : C) ‚ü∂ ùüô_ _ := !_ _

theorem Var?.Wk.den_zero {v : Var? Œ±} {A : Ty Œ±} (h : v.Wk ‚ü®A, 0‚ü©)
  : Var?.Wk.den (C := C) h = (haveI _ := (h.unused_del rfl); !_ _)
  := by cases v with | mk _ q => cases q <;> rfl

@[simp]
theorem Var?.Wk.den_unused {v w : Var? Œ±} (h : v.Wk w) (hw : w.unused)
  : Var?.Wk.den (C := C) h
  = (haveI _ := (Var?.unused.del hw).anti h; !_ _) ‚â´ eqToHom (by simp [ety, hw])
  := by cases w; cases hw; rw [den_zero]; simp

theorem Var?.Wk.den_erase {v  w: Var? Œ±} (h : v ‚â§ w.erase)
  : Var?.Wk.den (C := C) h = (haveI _ := h.unused_del rfl; !_ _)
  := by simp

theorem Var?.Wk.den_quant {v : Var? Œ±} {A : Ty Œ±} {q : Quant} (h : v.Wk ‚ü®A, q‚ü©)
  : Var?.Wk.den (C := C) h = eqToHom (by rw [ety_eq_quant h])
  := by cases v with | mk _ q' =>
        cases q' with | zero => have h := h.q; cases h using EQuant.le.casesLE | _ => rfl

@[simp]
theorem Var?.Wk.den_used {v w : Var? Œ±} (h : v.Wk w) (hw : w.used)
  : Var?.Wk.den (C := C) h = eqToHom (by rw [ety_eq_used h hw])
  := by cases w with | mk A q => cases q using EQuant.casesZero with
    | zero => cases hw
    | rest q => rw [den_quant]

notation "vw‚ü¶" œÅ "‚üß" => Var?.Wk.den œÅ

@[simp]
def Ctx?.PWk.den {Œì Œî : Ctx? Œ±} : Œì.PWk Œî ‚Üí ((g‚ü¶ Œì ‚üß : C) ‚ü∂ g‚ü¶ Œî ‚üß)
  | .nil => ùüô (ùüô_ C)
  | .cons œÅ w => œÅ.den ‚äó (Var?.Wk.den w)

notation "pw‚ü¶" œÅ "‚üß" => Ctx?.PWk.den œÅ

@[simp]
def Ctx?.Wk.den {Œì Œî : Ctx? Œ±} : Œì.Wk Œî ‚Üí ((g‚ü¶ Œì ‚üß : C) ‚ü∂ g‚ü¶ Œî ‚üß)
  | .nil => ùüô (ùüô_ C)
  | .cons œÅ hvw => œÅ.den ‚äó vw‚ü¶ hvw ‚üß
  | .skip hŒì hv => (hŒì.den ‚äó !_ _) ‚â´ (œÅ_ _).hom

notation "w‚ü¶" œÅ "‚üß" => Ctx?.Wk.den œÅ

def Var.Ix.den {Œì : Ctx? Œ±} {v : Var? Œ±} (h : v.Ix Œì) : (g‚ü¶ Œì ‚üß : C) ‚ü∂ v‚ü¶ v ‚üß
  := Ctx?.Wk.den h ‚â´ (Œª_ _).hom

@[simp]
def Ctx?.At.den {v : Var? Œ±} {Œì : Ctx? Œ±} {n} : Œì.At v n ‚Üí ((g‚ü¶ Œì ‚üß : C) ‚ü∂ v‚ü¶ v ‚üß)
  | .here _ h => (!_ _ ‚äó (Var?.Wk.den h)) ‚â´ (Œª_ _).hom
  | .there x hw => (x.den ‚äó !_ _) ‚â´ (œÅ_ _).hom

@[simp]
theorem Ctx?.At.den_cast {v v' : Var? Œ±} {Œì Œì' : Ctx? Œ±} {n n'} (x : Œì.At v n)
  (hŒì : Œì = Œì') (hv : v = v') (hn : n = n')
  : (x.cast hŒì hv hn).den (C := C) = eqToHom (by rw [hŒì]) ‚â´ x.den ‚â´ eqToHom (by rw [hv])
  := by cases hŒì; cases hv; cases hn; simp

theorem Ctx?.At.den_cast_src {v : Var? Œ±} {Œì Œì' : Ctx? Œ±} {n} (x : Œì.At v n)
  (hŒì : Œì = Œì') : (x.cast_src hŒì).den (C := C) = eqToHom (by rw [hŒì]) ‚â´ x.den
  := by simp

theorem Ctx?.At.den_cast_trg {v v' : Var? Œ±} {Œì : Ctx? Œ±} {n} (x : Œì.At v n) (hv : v = v')
  : (x.cast_trg hv).den (C := C) = x.den ‚â´ eqToHom (by rw [hv])
  := by simp

theorem Ctx?.At.den_cast_idx {v : Var? Œ±} {Œì : Ctx? Œ±} {n n'} (x : Œì.At v n) (hn : n = n')
  : (x.cast_idx hn).den (C := C) = x.den := by simp

-- @[simp]
-- theorem Ctx?.At.den_zero {v w : Var? Œ±} {Œì : Ctx? Œ±} (h : (Œì.cons w).At v 0)
--   : h.den (C := C)
--   = (h.zero_cons_tail.den (C := C) ‚äó (Var?.Wk.den h.zero_cons_head)) ‚â´ (Œª_ _).hom
--   := by cases h; rfl

-- @[simp]
-- theorem Ctx?.At.den_succ {v w : Var? Œ±} {Œì : Ctx? Œ±} (h : (Œì.cons w).At v (n + 1))
--   : h.den (C := C)
--   = (h.succ_cons_tail.den (C := C) ‚äó h.succ_cons_head.den) ‚â´ (œÅ_ _).hom
--   := by cases h; rfl

def Var?.Split.den {u v w : Var? Œ±} : u.Split v w ‚Üí ((v‚ü¶ u ‚üß : C) ‚ü∂ v‚ü¶ v ‚üß ‚äó v‚ü¶ w ‚üß)
  | .neither _ => !_ _ ‚â´ (œÅ_ _).inv
  | .left h => vw‚ü¶h‚üß ‚â´ (œÅ_ _).inv
  | .right h => vw‚ü¶h‚üß ‚â´ (Œª_ _).inv
  | .sboth hu hv hw => (haveI _ := hu.copy; Œî_ _) ‚â´ (vw‚ü¶hv‚üß ‚äó vw‚ü¶hw‚üß)

@[simp]
theorem Var?.Split.den_neither {v : Var? Œ±} [hv : v.del]
  : (Split.neither hv).den (C := C) = !_ _ ‚â´ (œÅ_ _).inv := rfl

@[simp]
theorem Var?.Split.den_left {v w : Var? Œ±} (h : v ‚â§ w)
  : (Split.left h).den (C := C) = vw‚ü¶h‚üß ‚â´ (œÅ_ _).inv := rfl

@[simp]
theorem Var?.Split.den_right {v w : Var? Œ±} (h : v ‚â§ w)
  : (Split.right h).den (C := C) = vw‚ü¶h‚üß ‚â´ (Œª_ _).inv := rfl

@[simp]
theorem Var?.Split.den_sboth {u v w : Var? Œ±} (hu : u.scopy) (hv : u ‚â§ v) (hw : u ‚â§ w)
  : (Split.sboth hu hv hw).den (C := C) = (have _ := hu.copy; Œî_ _) ‚â´ (hv.den (C := C) ‚äó vw‚ü¶hw‚üß)
  := rfl

notation "vs‚ü¶" œÅ "‚üß" => Var?.Split.den œÅ

def Var?.SSplit.den {u v w : Var? Œ±} : u.SSplit v w ‚Üí ((v‚ü¶ u ‚üß : C) ‚ü∂ v‚ü¶ v ‚üß ‚äó v‚ü¶ w ‚üß)
  | .left _ => (œÅ_ _).inv
  | .right _ => (Œª_ _).inv
  | .sboth h => have _ := h.copy; Œî_ _

notation "vss‚ü¶" œÅ "‚üß" => Var?.SSplit.den œÅ

@[simp]
theorem Var?.SSplit.den_left (v : Var? Œ±) : (SSplit.left v).den (C := C) = (œÅ_ _).inv := rfl

@[simp]
theorem Var?.SSplit.den_right (v : Var? Œ±) : (SSplit.right v).den (C := C) = (Œª_ _).inv := rfl

@[simp]
theorem Var?.SSplit.den_sboth {v : Var? Œ±} (h : v.scopy)
  : (SSplit.sboth h).den (C := C) = have _ := h.copy; Œî_ _ := rfl

theorem Var?.Wk.den_eff_in {v : Var? Œ±} {A : Ty Œ±} {q}
  (h : v ‚â§ ‚ü®A, q‚ü©) (h' : v ‚â§ ‚ü®A, q‚ü©)
  : Var?.Wk.den (C := C) h = Var?.Wk.den h'
  := by cases q using EQuant.casesZero <;> simp

end MonoidalCategoryStruct

section BraidedCategory

variable [PremonoidalCategory C] [BraidedCategory' C] [VarModel Œ± C]

@[simp]
def Ctx?.Split.den {Œì Œî Œû : Ctx? Œ±} : Œì.Split Œî Œû ‚Üí ((g‚ü¶ Œì ‚üß : C) ‚ü∂ g‚ü¶ Œî ‚üß ‚äó g‚ü¶ Œû ‚üß)
  | .nil => (Œª_ _).inv
  | .cons œÉ hlr => (œÉ.den ‚äó hlr.den) ‚â´ (Œ≤i_ _ _ _ _).hom

notation "cs‚ü¶" œÅ "‚üß" => Ctx?.SSplit.den œÅ

@[simp]
def Ctx?.SSplit.den {Œì Œî Œû : Ctx? Œ±} : Œì.SSplit Œî Œû ‚Üí ((g‚ü¶ Œì ‚üß : C) ‚ü∂ g‚ü¶ Œî ‚üß ‚äó g‚ü¶ Œû ‚üß)
  | .nil => (Œª_ _).inv
  | .cons œÉ hlr => (œÉ.den ‚äó hlr.den) ‚â´ (Œ≤i_ _ _ _ _).hom

notation "css‚ü¶" œÅ "‚üß" => Ctx?.SSplit.den œÅ

end BraidedCategory

end VarModel

variable {œÜ : Type _} {Œ± : Type _} {Œµ : Type _} [Signature œÜ Œ± Œµ]
         {C : Type _} [Category C] [PremonoidalCategory C] [ChosenFiniteCoproducts C]
         [BraidedCategory' C] [Iterate C] [E : Elgot2 C Œµ]
         [M : Model œÜ Œ± Œµ C]

@[simp]
theorem Var?.Wk.den_refl {v : Var? Œ±} : Var?.Wk.den (C := C) (le_refl v) = ùüô _
  := by cases v with | mk _ q => cases q using EQuant.casesZero with
  | zero => apply M.drop_unit
  | rest => rfl

@[simp]
theorem Var?.del.den_pure {v : Var? Œ±} (h : v.del) : E.HasEff e (!_ v.ety) := inferInstance

@[simp]
theorem Var?.copy.den_pure {v : Var? Œ±} (h : v.copy) : E.HasEff e (Œî_ v.ety) := inferInstance

@[simp]
instance Var?.Wk.den_pure {e : Œµ} {v w : Var? Œ±} (h : v ‚â§ w)
  : E.HasEff e <| Var?.Wk.den h
  := by cases v with | mk _ qv => cases w with | mk _ qw => cases qw using EQuant.casesZero with
    | zero => rw [den_zero]; infer_instance
    | rest qw => rw [den_quant]; infer_instance

instance Var?.Wk.den_central {v w : Var? Œ±} (h : v ‚â§ w)
  : Central (C := C) (Var?.Wk.den h)
  := (den_pure h).pure_central

@[simp]
theorem Var?.Wk.den_comp {u v w : Var? Œ±} (h : u ‚â§ v) (h' : v ‚â§ w)
  : den h ‚â´ den h' = den (C := C) (le_trans h h')
  := by cases u with | mk _ qu => cases v with | mk _ qv => cases w with | mk _ qw =>
    cases qw using EQuant.casesZero with
    | zero =>
      simp
      exact M.drop_aff (‚ä• : Œµ) _ (hA := ety_aff_zero (le_trans h h')) (hB := ety_aff_zero h')
    | rest qw =>  cases qv using EQuant.casesZero with
    | zero => cases h'.q using EQuant.le.casesLE
    | rest qv => simp

@[simp]
theorem Var?.Wk.den_comp_drop {v w : Var? Œ±} (h : v ‚â§ w) [hw : w.del]
  : Var?.Wk.den (C := C) h ‚â´ !_ w.ety = (haveI _ := hw.anti h; !_ v.ety)
  := by rw [M.drop_aff ‚ä• _ (hA := (hw.anti h).ety_aff)]

@[simp]
theorem Var?.del.den_unused {v : Var? Œ±} (hv : v.unused)
  : (haveI _  := hv.del; !_ v.ety) = eqToHom (C := C) (by simp [ety, hv])
  := by cases v; cases hv; simp [M.drop_unit]

@[simp]
theorem Var?.Wk.den_from_unused {v w : Var? Œ±} (h : v ‚â§ w) (h' : v.unused)
  : Var?.Wk.den (C := C) h
  = eqToHom (by cases v; cases w; cases h'; cases h.q using EQuant.le.casesLE; rfl)
  := by cases v; cases w; cases h'; cases h.q using EQuant.le.casesLE;
        simp [den_zero (C := C) h, M.drop_unit]

theorem Var?.Wk.den_from_zero {v : Var? Œ±} {A : Ty Œ±} (h : ‚ü®A, 0‚ü© ‚â§ v)
  : Var?.Wk.den (C := C) h = eqToHom (by cases v; cases h.q using EQuant.le.casesLE; rfl)
  := by simp

theorem Var?.Wk.den_from_erase {v w : Var? Œ±} (h : v.erase ‚â§ w)
  : Var?.Wk.den (C := C) h = eqToHom (by cases v; cases w; cases h.q using EQuant.le.casesLE; rfl)
  := by simp

@[simp]
instance Var?.Split.den_pure {u v w : Var? Œ±} (h : u.Split v w) : E.HasEff e h.den
  := by cases h <;> simp <;> infer_instance

@[simp]
instance Var?.Split.den_central {u v w : Var? Œ±} (h : u.Split v w) : Central (C := C) h.den
  := (den_pure h).pure_central

@[simp]
instance Var?.SSplit.den_pure {u v w : Var? Œ±} (h : u.SSplit v w) : E.HasEff e h.den
  := by cases h <;> simp; infer_instance

@[simp]
instance Var?.SSplit.den_central {u v w : Var? Œ±} (h : u.SSplit v w) : Central (C := C) h.den
  := (den_pure h).pure_central

instance Ctx?.PWk.den_pure {Œì Œî : Ctx? Œ±} (h : Œì.PWk Œî) : E.HasEff e h.den
  := by induction h with
  | nil => simp only [den]; exact HasEff.id
  | cons => simp only [den]; infer_instance

instance Ctx?.PWk.den_central {Œì Œî : Ctx? Œ±} (h : Œì.PWk Œî) : Central (C := C) h.den
  := (den_pure h).pure_central

instance Ctx?.Wk.den_pure {Œì Œî : Ctx? Œ±} (h : Œì.Wk Œî) : E.HasEff e h.den := by induction h with
  | nil => simp only [den]; exact HasEff.id
  | skip =>
    simp only [den]; apply HasEff.comp (hf := _) (hg := _); apply HasEff.tensorHom; infer_instance
  | cons => simp only [den]; infer_instance

instance Ctx?.Wk.den_central {Œì Œî : Ctx? Œ±} (h : Œì.Wk Œî) : Central (C := C) h.den
  := (den_pure h).pure_central

theorem Ctx?.PWk.den_toWk {Œì Œî : Ctx? Œ±} (œÅ : Œì.PWk Œî)
  : œÅ.toWk.den = œÅ.den (C := C) := by induction œÅ <;> simp [*]

@[simp]
theorem Ctx?.Wk.den_refl {Œì : Ctx? Œ±} : (Ctx?.Wk.refl Œì).den (C := C) = ùüô (g‚ü¶ Œì ‚üß) := by
  induction Œì <;> simp [*] <;> rfl

@[reassoc]
theorem Ctx?.Wk.den_comp {Œì Œî Œû : Ctx? Œ±} (h : Œì.Wk Œî) (h' : Œî.Wk Œû)
  : h.den ‚â´ h'.den = (h.comp h').den (C := C)
  := by induction h generalizing Œû with
  -- TODO: why is this not simping?
  | nil => cases h'; simp [den, Wk.comp]; apply Category.id_comp
  | skip _ _ I => simp only [
      den, Wk.comp, <-rightUnitor_naturality, <-comp_whiskerRight_assoc, I,
      tensorHom_def, Central.left_exchange, Category.assoc]
  | cons _ hv I => cases h' with
  | skip _ hw => simp [den, Wk.comp, <-tensor_comp_of_left_assoc, I]
  | cons => simp [den, Wk.comp, <-tensor_comp_of_left, I]

@[simp]
theorem Ctx?.Wk.den_comp_drop {Œì Œî : Ctx? Œ±} (œÅ : Œì.Wk Œî) [hŒî : Œî.del]
  : œÅ.den (C := C) ‚â´ !_ Œî.ety = (haveI _ := hŒî.wk œÅ; !_ Œì.ety)
  := have _ := hŒî.wk œÅ; M.drop_aff ‚ä• _

@[simp]
theorem Ctx?.PWk.den_refl {Œì : Ctx? Œ±} : (refl Œì).den (C := C) = ùüô (g‚ü¶ Œì ‚üß) := by
  induction Œì <;> simp [*] <;> rfl

theorem Ctx?.PWk.den_single {Œì : Ctx? Œ±} {v w : Var? Œ±} (h : v ‚â§ w) :
  ((refl Œì).cons h).den (C := C) = _ ‚óÅ h.den := by simp

theorem Ctx?.PWk.den_double {Œì : Ctx? Œ±} {v w v' w': Var? Œ±} (h : v ‚â§ w) (h' : v' ‚â§ w')
  : (((refl Œì).cons h).cons h').den (C := C) = (_ ‚óÅ h.den) ‚ñ∑ _ ‚â´ _ ‚óÅ h'.den
    := by simp [tensorHom_def]

theorem Ctx?.PWk.den_comp {Œì Œî Œû : Ctx? Œ±} (œÅ : Œì.PWk Œî) (œÅ' : Œî.PWk Œû)
  : œÅ.den ‚â´ œÅ'.den = (œÅ.comp œÅ').den (C := C)
  := by rw [<-œÅ.den_toWk, <-œÅ'.den_toWk, Wk.den_comp, <-PWk.comp_toWk, den_toWk]

instance Ctx?.At.den_pure {v : Var? Œ±} {Œì : Ctx? Œ±} {n} (h : Œì.At v n)
  : E.HasEff e h.den
  := by induction h <;> simp <;> infer_instance

instance Ctx?.At.den_central {v : Var? Œ±} {Œì : Ctx? Œ±} {n} (h : Œì.At v n)
  : Central (C := C) h.den
  := (den_pure h).pure_central

@[simp]
instance Ctx?.Split.den_pure {Œì Œî Œû : Ctx? Œ±} (h : Œì.Split Œî Œû) : E.HasEff e h.den
  := by induction h <;> simp; infer_instance

@[simp]
instance Ctx?.SSplit.den_pure {Œì Œî Œû : Ctx? Œ±} (h : Œì.SSplit Œî Œû) : E.HasEff e h.den
  := by induction h <;> simp; infer_instance

@[simp]
instance Ctx?.SSplit.den_central {Œì Œî Œû : Ctx? Œ±} (h : Œì.SSplit Œî Œû) : Central (C := C) h.den
  := (den_pure h).pure_central

@[simp]
theorem Ctx?.At.den_wkOut {v w : Var? Œ±} {Œì : Ctx? Œ±} {n} (hŒìv : Œì.At v n) (hvw : v ‚â§ w)
  : hŒìv.den (C := C) ‚â´ Var?.Wk.den hvw = (hŒìv.wkOut hvw).den
  := by induction hŒìv with
  | here =>
    simp only [Ctx?.den, ety, Ty.den, tensorHom_def, Category.assoc, ‚Üê
      leftUnitor_naturality, Ctx?.At.den, Ctx?.At.wkOut]
    rw [<-PremonoidalCategory.whiskerLeft_comp_assoc, Var?.Wk.den_comp]
  | there _ _ I =>
    simp only [Ctx?.At.den, Ctx?.At.wkOut, Category.assoc, ‚Üê rightUnitor_naturality]
    rw [tensorHom_def_of_left, tensorHom_def_of_left]
    simp only [Category.assoc]
    rw [<-comp_whiskerRight_assoc, I]

@[simp]
theorem Ctx?.At.den_wkIn {Œì Œî : Ctx? Œ±} (w : Œì.Wk Œî) {v n} (hŒîv : Œî.At v n)
  : w.den (C := C) ‚â´ hŒîv.den = (hŒîv.wkIn w).den := by induction w generalizing n with
  | nil => cases hŒîv
  | skip => simp [
    <-PremonoidalCategory.rightUnitor_naturality, <-tensorHom_id,
    <-tensor_comp_of_left_assoc, Ctx?.At.wkIn, *]
  | cons œÅ _ => cases hŒîv <;> simp [<-tensor_comp_of_left_assoc, Wk.den_comp, Ctx?.At.wkIn, *]

@[simp]
theorem Ctx?.At.den_pwk {Œì Œî : Ctx? Œ±} (œÅ : Œì.PWk Œî) {v n} (hŒîv : Œî.At v n)
  : œÅ.den (C := C) ‚â´ hŒîv.den = (hŒîv.pwk œÅ).den
  := by rw [<-œÅ.den_toWk, hŒîv.den_wkIn, hŒîv.wkIn_toWk]; simp

-- theorem Var?.Split.wk_den {u' u v w : Var? Œ±} (œÅ : u' ‚â§ u) (œÉ : u.Split v w)
--   : Var?.Wk.den œÅ ‚â´ œÉ.den (C := C)
--   = (œÉ.wk œÅ).den ‚â´ (Var?.Wk.den (C := C) (œÉ.leftWk œÅ) ‚äó Var?.Wk.den (œÉ.rightWk œÅ))
--   := by cases u with | mk A q => cases q using EQuant.casesZero with
--   | zero => cases œÉ with
--     | sboth h => cases h.q using EQuant.le.casesLE
--     | right =>
--       simp only [
--         ety_quant_zero, leftUnitor_inv_naturality, rightUnitor_inv_naturality,
--         id_tensorHom, wk, Wk.den_zero, den_right
--       ]
--       simp
--     | left =>
--       apply (cancel_mono (f := (œÅ_ (ùüô_ C)).hom)).mp
--       simp [ety_quant_zero, id_tensorHom, unitors_inv_equal]
--   | rest => cases œÉ with
--     | sboth h =>
--       simp [den, wkLeft_sboth, wkRight_sboth]
--       rw [
--         Model.copy_rel_ltimes ‚ä• _ (hA := (h.anti œÅ).copy.ety_rel) (hB := h.copy.ety_rel),
--         tensorHom_def
--       ]
--     | _ =>
--       simp only [
--         leftUnitor_inv_naturality, rightUnitor_inv_naturality,
--         tensorHom_id, id_tensorHom, Wk.den_quant, den_left, den_right
--       ]
--       simp

-- TODO: Ctx?.At.ix.den = Ctx?.At.den

-- TODO: Var?.Ix.at.den = Var?.Ix.den

-- TODO: PWk composition

-- TODO: den(PWk.toWk) = den(PWk)

-- TODO: SSplit ; swap

-- TODO: SSplit ==> SSplit, SSplit vs SSplit?

-- TODO: Split? SSplit?
